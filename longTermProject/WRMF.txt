from recommender import RecEngine
import baseline as base
import pyros.utils.cvx as utc
import cvxopt as co
import cvxopt.solvers as solver
import numpy as np
from scipy.sparse import csr_matrix
from pyros.utils.misc import fast_sparse_matrix


class WRMF(RecEngine):
	'''
	latent_factors : int
		Number of latent factors.
	alpha : float
		Confidence weight, confidence c = 1 + alpha*r where r is the observed "rating".
	lbda : float
		Regularization constant.
	num_iters : int
		Number of iterations of alternating least squares.
	'''
	def __init__(self, data, latent_factors, alpha=0.01, lbda=0.015, num_iters=15):
		super(self.__class__, self).__init__(data)
		self.R = fast_sparse_matrix(self.data.to_numpy_sparse_matrix().tocsr())
		self.latent_factors = latent_factors
		self.alpha = alpha
		self.lbda = lbda
		self.num_iters = num_iters
		self.model = None
		
	def init_factors(self,num_factors,assign_values=True):
		if assign_values:
			return self.latent_factors**-0.5*np.random.random_sample((num_factors,self.latent_factors))
		return np.empty((num_factors,self.latent_factors))

	def train(self, test_users=None):
		num_users,num_items = self.R.shape

		self.U = self.init_factors(num_users, False)  # don't need values, will compute them
		self.V = self.init_factors(num_items)
		for it in xrange(self.num_iters):
			print 'iteration',it
			# fit user factors
			VV = self.V.T.dot(self.V)
			for u in xrange(num_users):
				# get (positive i.e. non-zero scored) items for user
				indices = self.R.X[u].nonzero()[1]
				if indices.size:
					self.U[u,:] = self.update(indices,self.V,VV)
				else:
					self.U[u,:] = np.zeros(self.latent_factors)
			# fit item factors
			UU = self.U.T.dot(self.U)
			for i in xrange(num_items):
				indices = self.R.fast_get_col(i).nonzero()[0]
				if indices.size:
					self.V[i,:] = self.update(indices,self.U,UU)
				else:
					self.V[i,:] = np.zeros(self.latent_factors)
		
		self.model = np.dot(self.U,self.V.T)
		return self

	def update(self,indices,H,HH):
		Hix = H[indices,:]
		M = HH + self.alpha*Hix.T.dot(Hix) + np.diag(self.lbda*np.ones(self.latent_factors))
		return np.dot(np.linalg.inv(M),(1+self.alpha)*Hix.sum(axis=0))
	
	def get_params(self):
		return {'latent_factors':self.latent_factors, 'alpha':self.alpha, 'lambda':self.lbda, 'num_iters':self.num_iters}
	
	def get_scores(self, u):
		return co.matrix(self.model[u])